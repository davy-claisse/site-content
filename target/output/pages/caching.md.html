<div class="page-header">
<h1>
Caching
</h1>
</div>
<p>Caching is an integral part of every major system, It improves performance, reduces IO and makes overall user experience more pleasurable. Caching in ActiveJDBC works on the level of query and creation of model instances. For instance, the call:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;Library&gt; illLibs = Library.<span class="fu">where</span>(<span class="st">&quot;state = ?&quot;</span>, <span class="st">&quot;IL&quot;</span>);</code></pre></td></tr></table></div>
<p>might call into DB, or a result can come from cache, depending how cache and specifically model <code>Library</code> was configured</p>
<h2 id="cache-annotation">Cache annotation</h2>
<p>ActiveJDBC provides annotation to specify queries against which tables will be cached:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode java"><span class="fu">@Cached</span>
<span class="kw">public</span> <span class="kw">class</span> Library <span class="kw">extends</span> Model {}</code></pre></td></tr></table></div>
<p>As in other cases, this is a declaration that marks a model as &quot;cachable&quot;. If you enable logging (by providing a system property <code>activejdbc.log</code>), you will see extensive output from ActiveJDBC, similar to this:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode java"><span class="dv">3076</span> [main] INFO org.<span class="fu">javalite</span>.<span class="fu">activejdbc</span>.<span class="fu">DB</span> - Query: <span class="st">&quot;SELECT * FROM libraries WHERE id = ?&quot;</span>, with parameters: [<span class="dv">1</span>], took: <span class="dv">0</span> milliseconds
<span class="dv">3076</span> [main] INFO org.<span class="fu">javalite</span>.<span class="fu">activejdbc</span>.<span class="fu">cache</span>.<span class="fu">QueryCache</span> - HIT, <span class="st">&quot;SELECT * FROM libraries WHERE id = ?&quot;</span>, with parameters: [<span class="dv">1</span>]
<span class="dv">3077</span> [main] INFO org.<span class="fu">javalite</span>.<span class="fu">activejdbc</span>.<span class="fu">DB</span> - Query: <span class="st">&quot;INSERT INTO libraries (address, state, city) VALUES (?, ?, ?)&quot;</span>, with parameters: [<span class="dv">123</span> Pirate Street, CA, Bloomington], took: <span class="dv">1</span> milliseconds
<span class="dv">3077</span> [main] INFO org.<span class="fu">javalite</span>.<span class="fu">activejdbc</span>.<span class="fu">cache</span>.<span class="fu">QueryCache</span> - table cache purged <span class="kw">for</span>: libraries
<span class="dv">3077</span> [main] INFO org.<span class="fu">javalite</span>.<span class="fu">activejdbc</span>.<span class="fu">cache</span>.<span class="fu">QueryCache</span> - table cache purged <span class="kw">for</span>: books
<span class="dv">3077</span> [main] INFO org.<span class="fu">javalite</span>.<span class="fu">activejdbc</span>.<span class="fu">cache</span>.<span class="fu">QueryCache</span> - MISS, <span class="st">&quot;SELECT * FROM libraries WHERE id = ?&quot;</span>, with parameters: [<span class="dv">1</span>]
<span class="dv">3078</span> [main] INFO org.<span class="fu">javalite</span>.<span class="fu">activejdbc</span>.<span class="fu">DB</span> - Query: <span class="st">&quot;SELECT * FROM libraries WHERE id = ?&quot;</span>, with parameters: [<span class="dv">1</span>], took: <span class="dv">0</span> milliseconds</code></pre></td></tr></table></div>
<h2 id="cache-configuration-aj-version-1.1-and-above">Cache Configuration (AJ Version 1.1 and above)</h2>
<p>The new cache configuration includes providing a cache manager class name in the file <code>activejdbc.properties</code>. This file will have to be on the root of classpath. Here is one example:</p>
<pre class="prettyprint"><code>#inside file: activejdbc.properties
#or EHCache:
cache.manager=org.javalite.activejdbc.cache.EHCacheManager
#cache.manager=org.javalite.activejdbc.cache.OSCacheManager</code></pre>
<p>Here two things happen: 1. Cache in general is enabled (it is not enabled even if you have <span class="citation">@Cached</span> annotations on classes), and 2. AJ will be using EHCacheManager as implementation of cache.</p>
<h2 id="automatic-cache-purging">Automatic cache purging</h2>
<p>If you examine the log from above, you will see that after an insert statement into the &quot;LIBRARIES&quot; table, the system is purging cache related to this table, as well as &quot;BOOKS&quot; table. ActiveJDBC does this since the cache in memory might be potentially of out sync with the data in the DB, and hence will be purged. Related tables' caches are also purged. Since there exists relationship: library has many books, the books cache could also be stale, and this is a reason why a table &quot;BOOKS&quot; purged as well.</p>
<h2 id="manual-cache-purging">Manual cache purging</h2>
<p>If you want to manually purge caches (in cases you make destructive data operations outside Model API), you can do so:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">org.<span class="fu">javalite</span>.<span class="fu">activejdbc</span>.<span class="fu">cache</span>.<span class="fu">QueryCache</span>.<span class="fu">instance</span>().<span class="fu">purgeTableCache</span>(<span class="st">&quot;books&quot;</span>);</code></pre></td></tr></table></div>
<p>or:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">Books.<span class="fu">purgeCache</span>();</code></pre></td></tr></table></div>
<h2 id="what-to-cache">What to cache</h2>
<p>While caching is a complex issue, I can suggest caching predominantly lookup data. Lookup data is something that does not change very frequently. If you start caching everything, you might run into a problem of cache thrashing where you fill cache with data, and purge it soon after, without having a benefit of caching. Instead of improving performance, you will degrade it with extra CPU, RAM and IO (is cluster is configured) used and little or no benefit of having a cache in the first place.</p>
<h2 id="things-to-be-careful-about">Things to be careful about</h2>
<h3 id="potential-for-memory-leaks">Potential for memory leaks</h3>
<p>ActiveJDBC caches results from queries on object level. For instance, lets consider this code:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">
<span class="fu">@Cached</span>
<span class="kw">public</span> <span class="kw">class</span> <span class="fu">Student</span>(){}

...

List&lt;Student&gt; students = professor.<span class="fu">getAll</span>(Student.<span class="fu">class</span>); </code></pre></td></tr></table></div>
<p>Essentially the framework generates a query like this:</p>
<div class="sourceCode"><table class="sourceCode sql numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> students <span class="kw">WHERE</span> professor_id = ?;</code></pre></td></tr></table></div>
<p>and sets a parameter <code>professor_id</code> to prepared statement. Since the model <code>Student</code> is <code>@Cached</code>, then entire <code>List&lt;Student&gt; students</code> list will be cached.</p>
<blockquote>
<p>The key to the list as a cached object is a combination of query text as well as all parameters to the query.</p>
</blockquote>
<p>As a result, these two queries:</p>
<div class="sourceCode"><table class="sourceCode sql numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode sql"><span class="kw">SELECT</span> * <span class="kw">FROM</span> students <span class="kw">WHERE</span> professor_id = <span class="dv">1</span>;
<span class="kw">SELECT</span> * <span class="kw">FROM</span> students <span class="kw">WHERE</span> professor_id = <span class="dv">2</span>;</code></pre></td></tr></table></div>
<p>will produce two independent lists in cache just because their parameters are different. So, what will happen if you run many thousands or millions of queries that are the same, but only differ in parameters? You guess it, you will end up with millions of useless objects in cache and eventually will get an <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/OutOfMemoryError.html">OutOfMemoryError</a>.</p>
<p>The solution is to examine code, and ensure you are caching objects that are actually reusable.</p>
<p>It is possible to access and manage cache directly instead of <code>@Cached</code> annotation:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">
<span class="kw">import org.javalite.activejdbc.Registry;</span>

CacheManager manager = Registry.<span class="fu">cacheManager</span>();
manager.<span class="fu">addCache</span>(group, key, object); 

<span class="co">///then later in code: </span>

List&lt;Students&gt; students = (List&lt;Students&gt;)manager.<span class="fu">getCache</span>(group, key);</code></pre></td></tr></table></div>
<p>This way, you have a fine-tuned ability to only store specific objects in cache.</p>
<h3 id="cached-data-is-exposed-directly">Cached data is exposed directly</h3>
<p>When retrieving instances of cached models, be aware that exactly the same instances can be returned by subsequent calls to the same query. ActiveJDBC, as a lightweight framework, won't try to be &quot;intelligent&quot; and manage clones of cached data for you. So, for example, considering <code>Person</code> is annotated as <code>@Cached</code>, two subsequent calls to <code>Person.findById(1)</code> will return the same instance:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">Person p1 = Person.<span class="fu">findById</span>(<span class="dv">1</span>);
System.<span class="fu">out</span>.<span class="fu">println</span>(p1.<span class="fu">get</span>(<span class="st">&quot;name&quot;</span>)); <span class="co">// prints: John</span>

p1.<span class="fu">set</span>(<span class="st">&quot;name&quot;</span>, <span class="st">&quot;Jane&quot;</span>); <span class="co">// changes the cached data directly</span>
<span class="co">// don&#39;t save p1, and ...</span>

Person p2 = Person.<span class="fu">findById</span>(<span class="dv">1</span>); <span class="co">// ... find the same person again</span>
System.<span class="fu">out</span>.<span class="fu">println</span>(p2.<span class="fu">get</span>(<span class="st">&quot;name&quot;</span>)); <span class="co">// prints: Jane</span></code></pre></td></tr></table></div>
<h3 id="either-caching-or-optimistic-locking">Either caching or optimistic locking</h3>
<p>Caching and <a href="optimistic_locking" class="uri">optimistic_locking</a> don't get along. <strong>Don't use both together.</strong></p>
<p>Caching guarantees the result of subsequent calls to the same query return the same instances. So there can't be different versions of the same result set living in the memory shared by the cache manager. Suppose <code>Profile</code>, a model with <a href="optimistic_locking#when-collisions-happen">optimistic_locking</a>, is also annotated as <code>@Cached</code>. The following will happen:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">Profile p1 = Profile.<span class="fu">findById</span>(<span class="dv">1</span>);
Profile p2 = Profile.<span class="fu">findById</span>(<span class="dv">1</span>);
<span class="co">// p1 and p2 are actually references to the same instance.</span>

p1.<span class="fu">set</span>(<span class="st">&quot;profile_type&quot;</span>, <span class="st">&quot;hotel&quot;</span>);
p1.<span class="fu">saveIt</span>();
<span class="co">// record_version of the instance is incremented, then updated in the database.</span>

p2.<span class="fu">set</span>(<span class="st">&quot;profile_type&quot;</span>, <span class="st">&quot;vacation&quot;</span>);
p2.<span class="fu">saveIt</span>();
<span class="co">// As this is the same instance that had record_version incremented ealier,</span>
<span class="co">// its record_version value will match the database</span>
<span class="co">// and no StaleModelException will be thrown.</span></code></pre></td></tr></table></div>
<h3 id="relationships">Relationships</h3>
<p>ActiveJDBC manages caches for models and their respective relationships (read above), but in some cases you will use a query that ties together unrelated models:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;User&gt; users = User.<span class="fu">where</span>(<span class="st">&quot;id not in (select user_id from restricted_users)&quot;</span>);</code></pre></td></tr></table></div>
<p>If there exists a model User that is cached, and model RestrictedUser, and these tables/models have no relationship, then the line above could present a logical problem. If you execute the line above, and later change content of RESTRICTED_USERS table, then the query above will not see the change, and will return stale data. Developers need to be aware of this, and deal with these issues carefully. Whenever you change data in RESTRICTED_USERS table, please purge User model:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">User.<span class="fu">purgeCache</span>();</code></pre></td></tr></table></div>
<h3 id="destructive-operations">Destructive operations</h3>
<p>Whenever you execute a destructive operation against a model (INSERT, UPDATE, DELETE), the entire cache for that model is invalidated. This means that caches are best used for lookup data (duh!).</p>
<p>The framework will also invalidate and drop caches of all related tables. For instance:</p>
<p>Given the tables:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">create</span> <span class="kw">table</span> USERS (<span class="dt">INT</span> <span class="kw">id</span>, name <span class="dt">VARCHAR</span>);
<span class="kw">create</span> <span class="kw">table</span> ADDRESSES (<span class="dt">INT</span> <span class="kw">id</span>, street <span class="dt">VARCHAR</span>, city <span class="dt">VARCHAR</span>, user_id <span class="dt">INT</span>);</code></pre></div>
<p>and the models:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="fu">@Cached</span>
<span class="kw">public</span> <span class="kw">class</span> User <span class="kw">extends</span> Model{}

<span class="fu">@Cached</span>
<span class="kw">public</span> <span class="kw">class</span> Addressextends Model{}</code></pre></div>
<p>If you do this:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">user.<span class="fu">delete</span>();</code></pre></div>
<p>the framework will reset caches for both: User and Address models, not just user. This is done in order to prevent logical errors in the application.</p>
<p>Constantly changing cached data will then lead to <a href="https://en.wikipedia.org/wiki/Cache_stampede">Cache Stampede</a>.</p>
<h3 id="unrelating-models">Unrelating models</h3>
<p>In some cases, you need proper foreign keys in tables, but want to disconnect convention-based relationships in code</p>
<p>Given the tables:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">create</span> <span class="kw">table</span> USERS (<span class="dt">INT</span> <span class="kw">id</span>, name <span class="dt">VARCHAR</span>);
<span class="kw">create</span> <span class="kw">table</span> ADDRESSES (<span class="dt">INT</span> <span class="kw">id</span>, street <span class="dt">VARCHAR</span>, city <span class="dt">VARCHAR</span>, user_id <span class="dt">INT</span>);</code></pre></div>
<p>and the models:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="fu">@Cached</span>
<span class="kw">public</span> <span class="kw">class</span> User <span class="kw">extends</span> Model{}

<span class="fu">@Cached</span> <span class="fu">UnrelatedTo</span>({User.<span class="fu">class</span>})
<span class="kw">public</span> <span class="kw">class</span> Addressextends Model{}</code></pre></div>
<p>If you do this:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">user.<span class="fu">delete</span>();</code></pre></div>
<p>the framework will just reset the cache of the User model, and will not touch the cache of the Address model.</p>
<p>For more information, refer to JavaDoc: <a href="http://javalite.github.io/activejdbc/snapshot/org/javalite/activejdbc/annotations/UnrelatedTo.html">UnrelatedTo</a>.</p>
<h2 id="cache-providers">Cache providers</h2>
<p>ActiveJDBC has a simple plugin framework for adding cache providers. Currently supports:</p>
<ul>
<li>OSCache is dead now. Although it is working just fine on many of our projects, we recommend using EHCache</li>
<li><a href="http://ehcache.org/">EHCache</a>. EHCache is high performance popular open source project. For documentation, please refer to: <a href="http://ehcache.org/documentation" class="uri">http://ehcache.org/documentation</a></li>
<li>Redis - based cache provider (recent addition)</li>
</ul>
<h2 id="ehcache-configuration-v-2.x">EHCache configuration (v 2.x)</h2>
<p>Configuration needs to be provided in a file called <code>ehcache.xml</code> found at the root of a classpath. Example of a file content:</p>
<div class="sourceCode"><table class="sourceCode xml numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="sourceCode"><pre><code class="sourceCode xml"><span class="kw">&lt;ehcache</span><span class="ot"> xmlns:xsi=</span><span class="st">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
<span class="ot">         xsi:noNamespaceSchemaLocation=</span><span class="st">&quot;http://ehcache.org/ehcache.xsd&quot;</span>
<span class="ot">         updateCheck=</span><span class="st">&quot;true&quot;</span><span class="ot"> monitoring=</span><span class="st">&quot;autodetect&quot;</span><span class="kw">&gt;</span>

    <span class="kw">&lt;diskStore</span><span class="ot"> path=</span><span class="st">&quot;java.io.tmpdir&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;defaultCache</span>
<span class="ot">            maxElementsInMemory=</span><span class="st">&quot;1000&quot;</span>
<span class="ot">            eternal=</span><span class="st">&quot;false&quot;</span>
<span class="ot">            timeToIdleSeconds=</span><span class="st">&quot;120&quot;</span>
<span class="ot">            timeToLiveSeconds=</span><span class="st">&quot;120&quot;</span>
<span class="ot">            overflowToDisk=</span><span class="st">&quot;true&quot;</span>
<span class="ot">            maxElementsOnDisk=</span><span class="st">&quot;10000&quot;</span>
<span class="ot">            diskPersistent=</span><span class="st">&quot;false&quot;</span>
<span class="ot">            diskExpiryThreadIntervalSeconds=</span><span class="st">&quot;120&quot;</span>
<span class="ot">            memoryStoreEvictionPolicy=</span><span class="st">&quot;LRU&quot;</span>
            <span class="kw">/&gt;</span>
<span class="kw">&lt;/ehcache&gt;</span></code></pre></td></tr></table></div>
<p>Please, note that ActiveJDBC does not create named caches in EHCache, but only uses default configuration specified by <code>defaultCache</code> element in this file.</p>
<h2 id="ehcache-configuration-v-3.x">EHCache configuration (v 3.x)</h2>
<p>Name of the cache mamager class: <code>org.javalite.activejdbc.cache.EHCache3Manager</code>. Set the following in the file <code>activejsbc.properties</code>:</p>
<pre><code>cache.manager=org.javalite.activejdbc.cache.EHCache3Manager</code></pre>
<p>In addition, you will need to configure EHCacche itself. For that, add a file called <code>activejdbc-ehcache.xml</code>. Here is simple EHCache v3 configuration:</p>
<div class="sourceCode"><table class="sourceCode xml numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode xml"><span class="kw">&lt;ehcache:config</span><span class="ot"> xmlns:ehcache=</span><span class="st">&quot;http://www.ehcache.org/v3&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;ehcache:cache-template</span><span class="ot"> name=</span><span class="st">&quot;activejdbc&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;ehcache:expiry&gt;</span>
            <span class="kw">&lt;ehcache:none/&gt;</span>
        <span class="kw">&lt;/ehcache:expiry&gt;</span>
        <span class="kw">&lt;ehcache:eviction-prioritizer&gt;</span>LFU<span class="kw">&lt;/ehcache:eviction-prioritizer&gt;</span>
        <span class="kw">&lt;ehcache:heap</span><span class="ot"> size=</span><span class="st">&quot;5000&quot;</span><span class="ot"> unit=</span><span class="st">&quot;entries&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;/ehcache:cache-template&gt;</span>
<span class="kw">&lt;/ehcache:config&gt;</span></code></pre></td></tr></table></div>
<p>For more involved configuration options, refer to EHCache v3 documentation.</p>
<h2 id="redis-cache-configuration">Redis cache configuration</h2>
<p>Name of the cache mamager class: <code>org.javalite.activejdbc.cache.EHCache3Manager</code>. Set the following in the file <code>activejdbc.properties</code>:</p>
<pre><code>cache.manager=org.javalite.activejdbc.cache.RedisCacheManager</code></pre>
<p>Also, provide a property file called <code>activejdbc-redis.properties</code> with two properties: &lt;<code>redist-host</code> and <code>edist-port</code> The properties file needs to be at the root of classpath.</p>
<blockquote>
<p><strong>Limitation:</strong> Redis cache manager does not support <code>CacheManager#flush(CacheEvent)</code> with value 'ALL'.</p>
</blockquote>
