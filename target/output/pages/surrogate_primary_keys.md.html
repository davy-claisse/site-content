<div class="page-header">
<h1>
Surrogate primary keys
</h1>
</div>
<p>ActiveJDBC, relies on the surrogate primary keys. Description is found here: <a href="http://en.wikipedia.org/wiki/Surrogate_key" class="uri">http://en.wikipedia.org/wiki/Surrogate_key</a>. A surrogate key is not generated by ActiveJDBC. Unlike Hibernate, it does not (currently) have any generators for the keys and relies fully on DBMS solution to do this. Depending on a DB implementation, you can use various techniques to achieve this goal.</p>
<h2 id="key-name">Key name</h2>
<p>By convention, the primary key name is <code>id</code>. If your table has a surrogate primary key column with a name <code>id</code>, you do not have to do anything.</p>
<h2 id="key-value-insert-vs-update">Key Value, insert vs update</h2>
<p>When a new object of a model is created, the value of the ID is obviously <code>null</code>. When an object is looked up from a database, the ID value is populated to appropriately as any other attributes.</p>
<p>When a <code>save()</code> method is called, it will generate either an &quot;INSERT&quot; or &quot;UPDATE&quot; query, based on a value of the ID attribute. If the <code>id == null</code>, it will assume that this model represents a new record and will generate an INSERT, if the <code>id != null</code>, then it will generate an UPDATE query.</p>
<p>A developer could set an ID manually, but this is not its typical usage.</p>
<h2 id="override-standard-key-value-behavior">Override Standard Key Value behavior</h2>
<p>Usually you do not set ID of a model. ActiveJDBC will manage that. If you find setting ID of a model, stop and question what you are doing. If you indeed decide to do this, keep in mind that ActiveJDBC uses ID presence to determine if it needs to generate INSERT or UPDATE statements.</p>
<p>However, sometimes a developer knows better than the framework, when to update and when to insert. In such cases, you can call insert directly like so:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">Apple apple = <span class="kw">new</span> <span class="fu">Apple</span>();
apple.<span class="fu">set</span>(<span class="st">&quot;apple_type&quot;</span>, <span class="st">&quot;sweet&quot;</span>);
apple.<span class="fu">setId</span>(<span class="dv">1</span>);
apple.<span class="fu">insert</span>();

Apple apple1 = <span class="kw">new</span> <span class="fu">Apple</span>();
apple1.<span class="fu">set</span>(<span class="st">&quot;apple_type&quot;</span>, <span class="st">&quot;sour&quot;</span>);
apple1.<span class="fu">setId</span>(<span class="dv">2</span>);
apple1.<span class="fu">insert</span>();</code></pre></td></tr></table></div>
<p>This way you can fully control the value of the ID and still do either update or insert.</p>
<h2 id="what-about-composite-pks">What about composite PKs?</h2>
<p>You can have one of two scenarios:</p>
<h3 id="composite-keys-and-id-column">Composite keys and ID column</h3>
<p>You can have a composite PK in your table, as long as there is also an &quot;ID&quot; column ActiveJDBC can watch for inserts and updates. Composite keys are transparent to ActiveJDBC(in a sense it does not see or cares about them). This means that if you set attribute values into your model that violate the integrity of your data, ActiveJDBC will not complain, but the DB will (by throwing an exception save). This follows the same philosophy: ActiveJDBC does not implement what is already implemented by a lower level technology on stack.</p>
<h3 id="composite-keys-and-no-id-column">Composite keys and no ID column</h3>
<p>In some cases you cannot add a new column to an existing table. When this happens, ActibeJDBC stil provides some support. You can use a <code>CompositePK</code> annotation:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode java"><span class="fu">@CompositePK</span>({ <span class="st">&quot;first_name&quot;</span>, <span class="st">&quot;last_name&quot;</span>, <span class="st">&quot;email&quot;</span> })
<span class="kw">public</span> <span class="kw">class</span> Developer <span class="kw">extends</span> Model {
    <span class="dt">static</span> {
        <span class="fu">validatePresenceOf</span>(<span class="st">&quot;first_name&quot;</span>, <span class="st">&quot;last_name&quot;</span>, <span class="st">&quot;email&quot;</span>).<span class="fu">message</span>(
                <span class="st">&quot;one or more composite PK&#39;s missing!!!&quot;</span>);
    }
}</code></pre></td></tr></table></div>
<p>The validator (see above) can also be used to prevent a trip to a database in case you do not have all required columns for a composite PK. Searching with composite keys:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">Developer.<span class="fu">createIt</span>(<span class="st">&quot;first_name&quot;</span>, <span class="st">&quot;Johnny&quot;</span>, <span class="st">&quot;last_name&quot;</span>, <span class="st">&quot;Cash&quot;</span>, <span class="st">&quot;email&quot;</span>, <span class="st">&quot;j.cash@spam.org&quot;</span>, <span class="st">&quot;address&quot;</span>, <span class="st">&quot;123 Pine St&quot;</span>);
Developer dev = Developer.<span class="fu">findByCompositeKeys</span>(<span class="st">&quot;Johnny&quot;</span>, <span class="st">&quot;WrongName&quot;</span>, <span class="st">&quot;j.cash@spam.org&quot;</span>);
<span class="co">// ... </span></code></pre></td></tr></table></div>
<p>Ensure that the order of values is the same as in the definition of the <code>CompositePK</code> annotation. For more examples, refer to tests: <a href="https://github.com/javalite/activejdbc/blob/master/activejdbc/src/test/java/org/javalite/activejdbc/CompositePkTest.java">CompositePkTest.java</a></p>
<h2 id="override-primary-key">Override primary key</h2>
<p>If your table cannot provide a primary key column named <code>id</code> (for instance due to corporate naming standards), you can override it with <code>@IdName</code> annotation.</p>
<p>Example: let's say you have a table PEOPLE:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> people (
  person_id <span class="dt">int</span>(<span class="dv">11</span>) <span class="kw">NOT</span> <span class="kw">NULL</span> AUTO_INCREMENT,
  first_name              <span class="dt">VARCHAR</span>(<span class="dv">124</span>),
  last_name               <span class="dt">VARCHAR</span>(<span class="dv">124</span>),
)</code></pre></div>
<p>You will then put annotation on the model:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode java"><span class="fu">@IdName</span>(<span class="st">&quot;person_id&quot;</span>)
<span class="kw">public</span> <span class="kw">class</span> Person <span class="kw">extends</span> Model{}</code></pre></td></tr></table></div>
<p>This way, the model will know to work with column <code>person_id</code> and not <code>id</code> as a primary key.</p>
<h2 id="mysql-usage">MySQL usage</h2>
<p>MySQL probably has the best support for this feature, since it has a direct syntax for them:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> people (
  <span class="kw">id</span>  <span class="dt">INT</span>(<span class="dv">11</span>) <span class="kw">DEFAULT</span> <span class="kw">NULL</span> AUTO_INCREMENT <span class="kw">PRIMARY</span> <span class="kw">KEY</span>, 
  first_name <span class="dt">VARCHAR</span>(<span class="dv">56</span>), 
  last_name <span class="dt">VARCHAR</span>(<span class="dv">56</span>), 
  dob <span class="dt">DATE</span>, 
  graduation_date <span class="dt">DATE</span>, 
  created_at DATETIME, 
  updated_at DATETIME);</code></pre></div>
<p>This example is taken from ActiveJDBC tests. The surrogate PK <code>id</code> will be properly incremented by MySQL.</p>
<p>Example:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">Person p = <span class="kw">new</span> <span class="fu">Person</span>();
p.<span class="fu">getId</span>(); <span class="co">//&lt;&lt;&lt; ===== returns null</span>
p.<span class="fu">set</span>(<span class="st">&quot;first_name&quot;</span>, <span class="st">&quot;Igor&quot;</span>).<span class="fu">set</span>(<span class="st">&quot;last_name&quot;</span>, <span class="st">&quot;Polevoy&quot;</span>).<span class="fu">saveIt</span>();
p.<span class="fu">getId</span>(); <span class="co">//&lt;&lt;&lt; ===== returns non-null value, type depends on DBMS driver conversion</span></code></pre></td></tr></table></div>
<h2 id="oracle-usage-with-sequences-and-triggers">Oracle usage with sequences and triggers</h2>
<p>In Oracle things a bit more involved. The strategy is to create a sequence to generate numbers, and trigger to enter these numbers into the <strong>id</strong> column when inserting and not doing this when updating. In other words, if there an insert or update statement without this value, trigger provides one from a sequence, and if one is already provided by the SQL statement, trigger just ignores it.</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> people (
   <span class="kw">id</span>  <span class="dt">NUMBER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, 
   name <span class="dt">VARCHAR</span>(<span class="dv">56</span>), 
   last_name <span class="dt">VARCHAR</span>(<span class="dv">56</span>), 
   dob <span class="dt">DATE</span>, 
   graduation_date <span class="dt">DATE</span>, 
   created_at <span class="dt">TIMESTAMP</span>, 
   updated_at <span class="dt">TIMESTAMP</span>)

<span class="kw">ALTER</span> <span class="kw">TABLE</span> people <span class="kw">ADD</span> <span class="kw">CONSTRAINT</span> people_pk <span class="kw">PRIMARY</span> <span class="kw">KEY</span> ( <span class="kw">id</span> )

<span class="kw">CREATE</span> <span class="kw">SEQUENCE</span> people_seq <span class="kw">START</span> <span class="kw">WITH</span> <span class="dv">1</span> <span class="kw">INCREMENT</span> <span class="kw">BY</span> <span class="dv">1</span>

<span class="kw">CREATE</span> <span class="kw">OR</span> <span class="kw">REPLACE</span> <span class="kw">TRIGGER</span> people_trigger
    <span class="kw">BEFORE</span> <span class="kw">INSERT</span> <span class="kw">ON</span> people <span class="kw">REFERENCING</span>
    <span class="kw">NEW</span> <span class="kw">AS</span> <span class="kw">new</span>
    <span class="kw">OLD</span> <span class="kw">AS</span> <span class="kw">old</span>
    <span class="kw">FOR</span> <span class="kw">EACH</span> <span class="kw">ROW</span>
    <span class="kw">begin</span>
<span class="kw">select</span> <span class="kw">coalesce</span>(<span class="ch">:new</span>.id, people_seq.nextval) <span class="kw">into</span> <span class="ch">:new</span>.id <span class="kw">from</span> dual;
<span class="kw">end</span>;</code></pre></div>
<p>This SQL creates a DB structure that allows ActiveJDBC behave exactly the same as with MySQL:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">Person p = <span class="kw">new</span> <span class="fu">Person</span>();
p.<span class="fu">getId</span>(); <span class="co">//&lt;&lt;&lt; ===== returns null</span>
p.<span class="fu">set</span>(<span class="st">&quot;first_name&quot;</span>, <span class="st">&quot;Igor&quot;</span>).<span class="fu">set</span>(<span class="st">&quot;last_name&quot;</span>, <span class="st">&quot;Polevoy&quot;</span>).<span class="fu">saveIt</span>();
p.<span class="fu">getId</span>(); <span class="co">//&lt;&lt;&lt; ===== returns non-null value, type depends on DBMS driver conversion</span></code></pre></td></tr></table></div>
<h2 id="oracle-usage-with-sequences-and-no-triggers">Oracle usage with sequences and no triggers</h2>
<p>In order to reduce amount of SQL to generate your schema, you can adapt a simpler strategy: create only one sequence and use it as a source of generated values for all tables:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> people (
   <span class="kw">id</span>  <span class="dt">NUMBER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, 
   name <span class="dt">VARCHAR</span>(<span class="dv">56</span>), 
   last_name <span class="dt">VARCHAR</span>(<span class="dv">56</span>), 
   dob <span class="dt">DATE</span>, 
   graduation_date <span class="dt">DATE</span>, 
   created_at <span class="dt">TIMESTAMP</span>, 
   updated_at <span class="dt">TIMESTAMP</span>)

<span class="kw">ALTER</span> <span class="kw">TABLE</span> people <span class="kw">ADD</span> <span class="kw">CONSTRAINT</span> people_pk <span class="kw">PRIMARY</span> <span class="kw">KEY</span> ( <span class="kw">id</span> )

<span class="kw">CREATE</span> <span class="kw">SEQUENCE</span> main_seq <span class="kw">START</span> <span class="kw">WITH</span> <span class="dv">1</span> <span class="kw">INCREMENT</span> <span class="kw">BY</span> <span class="dv">1</span></code></pre></div>
<p>When defining a model, however, you will need to provide this piece of information to all models where you intend to use this sequence:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode java"><span class="fu">@IdGenerator</span>(<span class="st">&quot;main_seq.nextVal&quot;</span>)
<span class="kw">public</span> <span class="kw">class</span> Person <span class="kw">extends</span> Model{}</code></pre></td></tr></table></div>
<p>The usage code, behavior and expectations will be exactly the same with this strategy. As you can see, this seems to be simpler than using triggers, but it has a drawback. Since the same sequence will be used across multiple tables, the number values in a single table could (will) be out of sequence. But.. since this is a surrogate key anyway, it does not matter.</p>
<h2 id="postgresql-usage">PostgreSQL usage</h2>
<p>PostgreSQL has a capability similar to that of MySQL, but different syntax - no sequences are required:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> people (
   <span class="kw">id</span> SERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>, 
   name <span class="dt">VARCHAR</span>(<span class="dv">56</span>) <span class="kw">NOT</span> <span class="kw">NULL</span>, 
   last_name <span class="dt">VARCHAR</span>(<span class="dv">56</span>), 
   dob <span class="dt">DATE</span>, graduation_date <span class="dt">DATE</span>, 
   created_at <span class="dt">TIMESTAMP</span>, 
   updated_at <span class="dt">TIMESTAMP</span>);</code></pre></div>
<p>The keyword 'SERIAL' in PostgreSQL does the same as MySQL's AUTO_INCREMENT</p>
