<div class="page-header">
<h1>
One to many associations
</h1>
</div>
<p>One to many associations are pretty common in modern projects. Examples are: university has students, library has books, etc. There are two sides to a one to many association, the &quot;parent&quot; <strong>has a</strong> &quot;child&quot; and a &quot;child&quot; <strong>belongs to</strong> &quot;parent&quot;.</p>
<p>ActiveJDBC supports this type of a relationship in two ways: 1. Inferred and 2. Overridden</p>
<h2 id="example-tables">Example tables</h2>
<p>Lets define a couple of tables to start with:</p>
<p>Table <code>USERS</code>:</p>
<table style="width:67%;">
<colgroup>
<col width="6%" />
<col width="18%" />
<col width="16%" />
<col width="25%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">first_name</th>
<th align="left">last_name</th>
<th align="left">discipline</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p>1</p></td>
<td align="left"><p>John</p></td>
<td align="left"><p>Doe</p></td>
<td align="left"><p>otholaringology</p></td>
</tr>
<tr class="even">
<td align="left"><p>2</p></td>
<td align="left"><p>Hellen</p></td>
<td align="left"><p>Hunt</p></td>
<td align="left"><p>dentistry</p></td>
</tr>
</tbody>
</table>
<p>Table <code>ADDRESSES</code>:</p>
<table style="width:74%;">
<colgroup>
<col width="15%" />
<col width="15%" />
<col width="9%" />
<col width="11%" />
<col width="8%" />
<col width="13%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><p>address1</p></td>
<td align="left"><p>address2</p></td>
<td align="left"><p>city</p></td>
<td align="left"><p>state</p></td>
<td align="left"><p>zip</p></td>
<td align="left"><p>user_id</p></td>
</tr>
</tbody>
</table>
<h2 id="writing-models">Writing models</h2>
<p>Model for USERS table:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> User <span class="kw">extends</span> Model {}</code></pre></td></tr></table></div>
<p>Model for ADDRESSES table:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Address <span class="kw">extends</span> Model {}</code></pre></td></tr></table></div>
<blockquote>
<p>Just because table <code>ADDRESSES</code> has a column called <code>user_id</code>, the framework assumes that there is a one-to-many relationship here, and makes special arrangements. The framework (internally) creates two associations (User has many Address(es) and Address belongs to User).</p>
</blockquote>
<h2 id="adding-children">Adding children</h2>
<p>Adding children is the same as in any other association:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">user.<span class="fu">add</span>(address);</code></pre></td></tr></table></div>
<p>As in other associations, the requirement is that the parent record in DB must exist already. This way, a child model is immediately saved to its appropriate table.</p>
<blockquote>
<p>ActiveJDBC is a pass-through model. Models do not retain references to child model instances.</p>
</blockquote>
<p>In case the User model is new (has not been save yet), the method <code>user.add(child)</code> will throw an exception.</p>
<h2 id="how-to-get-children">How to get children</h2>
<p>Nothing can be simpler:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;Address&gt; addresses = user.<span class="fu">getAll</span>(Address.<span class="fu">class</span>);</code></pre></td></tr></table></div>
<p>Here the <code>Address.class</code> needs to be passed in because a model User might have many other relationships with other models.</p>
<h2 id="conditional-selection-of-related-objects">Conditional selection of related objects</h2>
<p>Sometimes you need to collect children of a model based on a selection criteria: In such cases, use the <code>get(type)</code> method:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;Address&gt; shippingAddresses = customer.<span class="fu">get</span>(Address.<span class="fu">class</span>, <span class="st">&quot;address_type = ?&quot;</span>, <span class="st">&quot;shipping&quot;</span>);</code></pre></td></tr></table></div>
<p>It is expected that the table <code>ADDRESSES</code> will have a column <code>address_type</code>. Condition is applied to a child table.</p>
<h2 id="how-to-get-parent">How to get Parent</h2>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">User user = address.<span class="fu">parent</span>(User.<span class="fu">class</span>);</code></pre></td></tr></table></div>
<p>Here, we have to pass a <code>User.class</code> to indicate which parent type we want because a model could have multiple parents.</p>
<h2 id="deleting-parent">Deleting Parent</h2>
<p>A simple way to delete a parent is:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">User u = address.<span class="fu">parent</span>(User.<span class="fu">class</span>);
u.<span class="fu">delete</span>();</code></pre></td></tr></table></div>
<p>If you have a referential integrity in your DB and table <code>ADDRESSES</code> has records associated with this user, then you will get an exception from DB. If you do not have child records, this user will be deleted. If you have records in the <code>ADDRESSES</code> table and no referential integrity constraint, the user will be deleted and you will have orphan records in the <code>ADDRESSES</code> table. In order to delete a user and all it's child records, execute this method:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">u.<span class="fu">deleteCascade</span>();</code></pre></td></tr></table></div>
<p>This method will walk over all parent/child relationships and delete the user and all child records associated with it. There is also a convenience methods that will do the same:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">u.<span class="fu">delete</span>(<span class="kw">true</span>);<span class="co">//true for cascade.</span></code></pre></td></tr></table></div>
<blockquote>
<p>Be extremely cautious with this method. See <a href="delete_cascade">Delete cascade</a> for more information.</p>
</blockquote>
<h2 id="override-conventions">Override Conventions</h2>
<p>In cases where a surrogate foreign key is already present and has a name that does not follow the ActiveJDBC conventions, you could easily override it like this:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode java"><span class="fu">@BelongsTo</span>(parent = User.<span class="fu">class</span>, foreignKeyName = <span class="st">&quot;usr_id&quot;</span>)
<span class="kw">public</span> <span class="kw">class</span> Address <span class="kw">extends</span> Model {}</code></pre></td></tr></table></div>
<p>The <code>@BelongsTo</code> annotation will ensure that API on both ends will work. ActiveJDBC does not have annotation <code>@HasMany</code>, since it would not be <a href="http://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself">DRY</a>.</p>
<p>In cases a model belongs to many parents, you can use this annotation:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode java"><span class="fu">@BelongsToParents</span>({ 
<span class="fu">@BelongsTo</span>(foreignKeyName=<span class="st">&quot;key_id&quot;</span>,parent=Keyboard.<span class="fu">class</span>), 
<span class="fu">@BelongsTo</span>(foreignKeyName=<span class="st">&quot;mother_id&quot;</span>,parent=Motherboard.<span class="fu">class</span>) 
}) </code></pre></td></tr></table></div>
<p>As usual though, you only need it if names of foreign keys do not conform to the conventions.</p>
<h2 id="foreign-key">Foreign Key</h2>
<p>The Foreign Key in the <code>ADDRESSES</code> table does not have to be a real Foreign Key constraint. ActiveJDBC does not check for it's presence. As long as there is a column named according to this convention, ActiveJDBC assumes that there is a relationship. It does not hurt to have the actual constraint in the DB if you are using other means of accessing data.</p>
