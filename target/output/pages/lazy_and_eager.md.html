<div class="page-header">
<h1>
Lazy and eager
</h1>
</div>
<p>ActiveJDBC is lazy by default. In this sense, it has semantics closer to ActiveRecord than Hibernate.</p>
<h2 id="lazy-list">Lazy List</h2>
<p>In a code like this:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;User&gt; users = User.<span class="fu">findAll</span>(); <span class="co">// or User.where(&quot;.. query here&quot;);</span>
<span class="kw">for</span>(User u: users){
    System.<span class="fu">out</span>.<span class="fu">println</span>(u);
}</code></pre></td></tr></table></div>
<p>the list <code>users</code> is a type of <a href="http://javalite.github.io/activejdbc/snapshot/org/javalite/activejdbc/LazyList.html">LazyList</a>.</p>
<p>Despite what it looks, the line 1. is not when the framework makes a call to the database. Only when the objects are queried from loop on line 2, the framework pulls data from the database.</p>
<p>In fact, in this example:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;Employee&gt; people = Employee.<span class="fu">where</span>(<span class="st">&quot;department = ? and hire_date &gt; ? &quot;</span>, <span class="st">&quot;IT&quot;</span>, hireDate)
    .<span class="fu">offset</span>(<span class="dv">21</span>)
    .<span class="fu">limit</span>(<span class="dv">10</span>)
    .<span class="fu">orderBy</span>(<span class="st">&quot;hire_date asc&quot;</span>);</code></pre></td></tr></table></div>
<p>there is no access to database. All that is happening is that the <a href="http://javalite.github.io/activejdbc/snapshot/org/javalite/activejdbc/LazyList.html">LazyList</a> is progressively configured on lines 2, 3 and 4 in order to build a correct SQL query when the objects are requested from the list.</p>
<h2 id="lazy-dependencies">Lazy dependencies</h2>
<p>If you have a model User and a model Address, and they have a one to many relationship, when a user has many addresses, the code:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">User u = User.<span class="fu">findById</span>(<span class="dv">1</span>);</code></pre></td></tr></table></div>
<p>does not load the associated addresses. Only when you call the getter for addresses, a query is generated and executed against DB:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;Address&gt; addresses = u.<span class="fu">getAll</span>(Address.<span class="fu">class</span>);</code></pre></td></tr></table></div>
<p>In the example above, the collection of addresses is not cached in the User model, and a query is executed against a DB as many times as this getter is called.</p>
<blockquote>
<p>ActiveJDBC uses a pass-through model. It means that the models do not cache relationships. Even after a call to get related objects the parent model does not retain a reference to them.</p>
</blockquote>
<h2 id="improve-efficiency-with-eager-loading">Improve efficiency with eager loading</h2>
<p>Let's consider an example where an ORM could unexpectedly generate a huge number of inefficient queries:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;Address&gt; addresses = Address.<span class="fu">findAll</span>();

<span class="kw">for</span>(Address address: addresses){
   User user = address.<span class="fu">parent</span>(User.<span class="fu">class</span>);
   System.<span class="fu">out</span>.<span class="fu">println</span>(user);
}</code></pre></td></tr></table></div>
<p>In the above example, the number of queries generated and executed is going to be N + 1, were N is a number of addresses. This is because the first query is to get all addresses, and then for each address, there is a new query to get a user parent (line 4).</p>
<p>This approach is going to kill performance in some applications. A better way is to load all parents at once by a single query:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;Address&gt; addresses = Address.<span class="fu">findAll</span>().<span class="fu">include</span>(User.<span class="fu">class</span>);

<span class="kw">for</span>(Address address: addresses){
   User user = address.<span class="fu">parent</span>(User.<span class="fu">class</span>);
   System.<span class="fu">out</span>.<span class="fu">println</span>(user);
}</code></pre></td></tr></table></div>
<p>ActiveJDBC will then issue two queries: one to get all Addresses and the other to get all corresponding Users for each address.</p>
<p>The same logic can be applied to all relationships <strong>going up and down</strong>: one-to-many, many-to-one and many-to-many.</p>
<blockquote>
<p>Relationships that were loaded by <code>include()</code> <em>are cached</em> and will be returned each time (without further access to DB) when the same getter is used!</p>
</blockquote>
<h2 id="eager-simultaneous-loading-of-parents-and-children">Eager simultaneous loading of parents and children</h2>
<p>Suppose we have two one to many relationships: Author has many Posts and a Post has many Comments. In cases like these, we can load a post and all corresponding Authors and Comments very efficiently:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;Post&gt; todayPosts = Post.<span class="fu">where</span>(<span class="st">&quot;post_date = ?&quot;</span>, today).<span class="fu">include</span>(Author.<span class="fu">class</span>, Comment.<span class="fu">class</span>);</code></pre></td></tr></table></div>
<p>The above code will generate only three queries to DB, one per each table. This of course will create an object graph in memory with certain implications. While it is going to be a more efficient approach from the point of DB IO view, it certainly will consume more memory. Developers will need to understand the implications and perform test cases to see if eager loading is improving or degrading performance.</p>
<h2 id="conversion-to-maps">Conversion to Maps</h2>
<p>When a model with included children is converted to a map, all the dependencies are converted to maps and inserted into a parent model map too. Here is an example:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">LazyList&lt;User&gt; users = User.<span class="fu">findAll</span>().<span class="fu">include</span>(Address.<span class="fu">class</span>);
List&lt;Map&gt; maps = users.<span class="fu">toMaps</span>();

Map user = maps.<span class="fu">get</span>(<span class="dv">0</span>);

List&lt;Map&gt; addresses = (List&lt;Map&gt;)user.<span class="fu">get</span>(<span class="st">&quot;addresses&quot;</span>);</code></pre></td></tr></table></div>
<p>In the example above, on line 1 a list of users is requested from a DB, and this list is to include corresponding addresses for each user. So far, this is the same as previous examples. However, on line 2 the users are converted to a list of maps. When this happens, each map that was generated from a user model also contains a list of maps each representing an address as a child of that user. What is more, is that the list of addresses is keyed from a user map by a string &quot;addresses&quot; as evident on line 6. The key in each case like this is an interpolation of a name of a child model to plural form according to the rules of the English language, which resulted in &quot;addresses&quot; in this case.</p>
<p>The same logic applies to many-to-one and many-to-many relationships.</p>
<h2 id="pre-loading-data-into-a-list">Pre-loading data into a list</h2>
<p>In some cases, you will need to force loading of data. One example, is when you are passing a list of models to another thread. Consider this code:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;User&gt; users = User.<span class="fu">where</span>(<span class="st">&quot;zip = ?&quot;</span>, <span class="dv">60606</span>).<span class="fu">limit</span>(<span class="dv">10</span>).<span class="fu">offset</span>(<span class="dv">20</span>);</code></pre></td></tr></table></div>
<p>As mentioned above, there was no access to the database. However, when you call any method of this class that requires any data from the database, the <code>List</code> will make a call to the underlying table to get the data.</p>
<p>This means, that if you just create a list like this and pass it off to another thread, and if that thread does not have a database connection attached to it, the list will not be able to load data and will throw exception complaining that a database connection was not found on this thread.</p>
<p>In order to pre-populate the list before passing it off, you need to call any method that will force loading (hydrating) of the list from the database. Example:</p>
<div class="sourceCode"><table class="sourceCode java numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode java">List&lt;User&gt; users = User.<span class="fu">where</span>(<span class="st">&quot;zip = ?&quot;</span>, <span class="dv">60606</span>).<span class="fu">limit</span>(<span class="dv">10</span>).<span class="fu">offset</span>(<span class="dv">20</span>);
users.<span class="fu">size</span>();</code></pre></td></tr></table></div>
<p>Even if you do not use the result of the method <code>size()</code>, it will load data into the list. Any successive calls to the list will bring cached (in the list) results.</p>
